# 將FIDO2加入現成專案


示意圖
## 研究目標

在現有的專案服務中加入FIDO2功能，以提升使用者的安全性和便利性。

## [passwordless-id / webauthn](https://github.com/passwordless-id/webauthn/tree/main)

### 安裝 webauthn 庫

```bash
npm install @passwordless-id/webauthn
```

## 前後端添加功能示意圖
![截圖 2024-03-26 下午5 29 10](https://github.com/CAFECA-IO/KnowledgeManagement/assets/123862185/ae6aaf30-7eb7-4da1-8a93-19e0c00744d5)

> [!WARNING] 由於瀏覽器安全設定，前端必須屬於Secure Origin才能使用，否則會有安全性限制，無法讀取某些瀏覽器敏感資料，因此API會呼叫失敗。

> [!TIP] 根據Chromium的網站說明，Secure Origin包含但不限制於以下幾種模式：
>
> - (https, *,*)
> - (wss, *,*)
> - (*, localhost,*)
> - (*, 127/8,*)
> - (*, ::1/128,*)
> - (file, *, —)
> - (chrome-extension, *, —)

## 使用情境：用戶授權給XXX網站登入，有效時間為60分鐘

基本上，FIDO2的加入可以分為兩個部分：註冊和登入。在註冊階段，使用者需要透過FIDO2設備進行身份驗證，並將公鑰傳送至伺服器進行註冊。在登入階段，使用者需要透過FIDO2設備進行身份驗證，並將簽名傳送至伺服器進行登入。

圍繞這兩個功能主要會使用到4個modules：

- client：用於在瀏覽器中調用webauthn
- server：用於在伺服器中驗證回應
- parsers：用於解析部分或全部已編碼數據，無需驗證
- utils：各種編碼、解碼、挑戰生成器和其他工具

前端的client部分主要負責調用webauthn API，並將獲得的公鑰傳送至伺服器進行註冊。後端的server部分主要負責驗證從前端獲得的簽名，並進行登入。

## 註冊程式範例

### 前端

1. 前端發送request到後端獲取挑戰，挑戰為一串隨機字串
2. 前端利用獲取的挑戰生成公鑰與資料

   - 傳送範例

   ```javascript
   import { client } from '@passwordless-id/webauthn' 

   const challenge = "a7c61ef9-dc23-4806-b486-2428938a547e"
   const name = "Arnaud"
   const options? = {
     authenticatorType: "auto",
     userVerification: "required",
     timeout: 60000,
     attestation: true,
     userHandle: "Optional server-side user id. Must not reveal personal information.",
     debug: false
   }
   const registration = await client.register(name, challenge, options)
   ```

   - 產生之registration object範例

    ```JSON
    {
    "username": "Arnaud",
    "credential": {
        "id": "3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU",
        "publicKey": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEgyYqQmUAmDn9J7dR5xl-HlyAA0R2XV5sgQRnSGXbLt_xCrEdD1IVvvkyTmRD16y9p3C2O4PTZ0OF_ZYD2JgTVA==",
        "algorithm": "ES256"
    },
    "authenticatorData": "SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NFAAAAAAiYcFjK3EuBtuEw3lDcvpYAIN_duB4SXSTMv7L51KME_HqF6zjjujSz_EivOatkT8XVpQECAyYgASFYIIMmKkJlAJg5_Se3UecZfh5cgANEdl1ebIEEZ0hl2y7fIlgg8QqxHQ9SFb75Mk5kQ9esvadwtjuD02dDhf2WA9iYE1Q=",
    "clientData": "eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiYTdjNjFlZjktZGMyMy00ODA2LWI0ODYtMjQyODkzOGE1NDdlIiwib3JpZ2luIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwIiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQ=="
    }
    ```

### 後端

1. 後端收到registration object，並驗證正確性

    ```javascript
    import { server } from '@passwordless-id/webauthn' 

    const expected = {
        challenge: "a7c61ef9-dc23-4806-b486-2428938a547e", // whatever was randomly generated by the server
        origin: "http://localhost:8080",
    }
    const registrationParsed = await server.verifyRegistration(registration, expected)
    ```

    - 產生之registrationParsed object範例

    ```JSON
    {
    "username": "Arnaud",
    "credential": {
        "id": "3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU",
        "publicKey": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEgyYqQmUAmDn9J7dR5xl-HlyAA0R2XV5sgQRnSGXbLt_xCrEdD1IVvvkyTmRD16y9p3C2O4PTZ0OF_ZYD2JgTVA==",
        "algorithm": "ES256"
    },
    "authenticator": {
        ...
        "name": "Windows Hello",
        "icon_dark": "https://webauthn.passwordless.id/authenticators/08987058-cadc-4b81-b6e1-30de50dcbe96-dark.png",
        "icon_light": "https://webauthn.passwordless.id/authenticators/08987058-cadc-4b81-b6e1-30de50dcbe96-light.png",
        "synced": true
    },
    ...
    }
    ```

    EdrawMax
2. 將憑證金鑰(credential)儲存至資料庫

## 登入程式範例

### 前端

1. 確認Session是否已經存在
2. 發送request到後端獲取挑戰，挑戰為一串隨機字串
3. 利用獲取的挑戰生成簽名並傳送至後端

   - 傳送範例

      ```javascript
      import { client } from '@passwordless-id/webauthn'

       if (session) {
       return 'session is already exist'
       }
       const challenge = async (challenge) => { /* 去後端查詢挑戰 */ return true },
       const credentialId = ["3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU"] //使用者名稱
       const authentication = await client.authenticate(credentialId, challenge, {
       "authenticatorType": "auto",
       "userVerification": "required",
       "timeout": 60000
       })
       ```

   - 回傳範例

    ```Json

    {
     "credentialId": "3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU",
     "authenticatorData": "SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAQ==",
     "clientData": "eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiNTY1MzViMTMtNWQ5My00MTk0LWEyODItZjIzNGMxYzI0NTAwIiwib3JpZ2luIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgwIiwiY3Jvc3NPcmlnaW4iOmZhbHNlLCJvdGhlcl9rZXlzX2Nhbl9iZV9hZGRlZF9oZXJlIjoiZG8gbm90IGNvbXBhcmUgY2xpZW50RGF0YUpTT04gYWdhaW5zdCBhIHRlbXBsYXRlLiBTZWUgaHR0cHM6Ly9nb28uZ2wveWFiUGV4In0=",
     "signature": "MEUCIAqtFVRrn7q9HvJCAsOhE3oKJ-Hb4ISfjABu4lH70MKSAiEA666slmop_oCbmNZdc-QemTv2Rq4g_D7UvIhWT_vVp8M="
     }
     ```

### 後端

1. 後端藉由authentication中的credentialId讀取資料庫中的資料與預期輸入值

    ```javascript
    import { server } from '@passwordless-id/webauthn' 

    // credentialKey 由 authentication.credentialId 去資料庫取得
    const credentialKey = { 
        id: "3924HhJdJMy_svnUowT8eoXrOOO6NLP8SK85q2RPxdU",
        publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEgyYqQmUAmDn9J7dR5xl-HlyAA0R2XV5sgQRnSGXbLt_xCrEdD1IVvvkyTmRD16y9p3C2O4PTZ0OF_ZYD2JgTVA==",
        algorithm: "ES256"
    } as const

    const expected = {
        challenge: async (challenge) => { /* 去資料庫查詢挑戰 */ return true },
        origin: (origin) => listOfAllowedOrigins.includes(origin), //符合的origin
        userVerified: true, // 若在authentication options 中`userVerification` 是`required` (預設值) 則此值必須是`true`
        counter: 123 // 選擇性. 目前Windows與Android支援，用於檢查計數器是否增加，以防止重放攻擊，IOS/MAC不支援，在雲端上則是一種`功能`
    }
    ```

2. 驗證數據與簽名正確性，並回傳登入結果

    ```javascript
    const authenticationParsed = await server.verifyAuthentication(authentication, credentialKey, expected)
    // authenticationParsed 無實際功能只是回傳值
    if (authenticationParsed != null) {
      //實作session並回傳到前端完成登入
    }
    ```

## 參考資料

- [passwordless-id / webauthn](https://github.com/passwordless-id/webauthn/tree/main)
