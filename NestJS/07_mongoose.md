# ODM, OEM, OBM, ORM  在數據庫代表什麼
在數據庫中，ODM、OEM、OBM和ORM代表了不同的映射技術，用於處理應用程序中的對象（Object）和數據庫中的不同數據形式之間的映射。這些技術在數據庫和軟體開發中被使用，以便於以面向物件的方式操作數據庫，而無需直接處理數據庫的底層細節。

### ODM (Object-Document Mapping)：物件-文件映射
- ODM 含義：
    - ODM是一種用於將應用程序中的物件（Object）映射到文檔型數據庫中的文檔（Document）的技術。常見的文檔型數據庫包括MongoDB。ODM工具允許開發人員使用面向物件的方式處理數據庫操作，並且提供了對數據庫文檔的抽象。
- ODM 效能損失：
    - 它提供了一個高級的抽象層來處理數據庫操作。由於提供了更多功能和抽象層，當處理大量數據或需要高效率的查詢時，ODM 可能比原生 MongoDB 驅動程序慢，因為它需要處理額外的抽象和轉換。 
### OEM (Object-Entity Mapping)：物件-實體映射
- OEM 含義：
    - OEM是一種用於將應用程序中的物件（Object）映射到關聯型數據庫中的實體（Entity）的技術。常見的關聯型數據庫包括MySQL、PostgreSQL等。OEM工具允許開發人員使用面向物件的方式處理數據庫操作，並將物件映射到數據庫中的表格。
- OEM 效能損失：
    - 當處理大量複雜的表關聯時，OEM 可能會導致效能降低，因為它需要處理物件和關聯型數據庫之間的轉換。
### ORM (Object-Relational Mapping)：物件-關聯型映射
- ORM 含義：
    - ORM 是用於關聯型數據庫的映射技術，類似於 OEM，ORM是一種用於將應用程序中的物件（Object）映射到關聯型數據庫中的表格（Relation）的技術。常見的關聯型數據庫包括MySQL、PostgreSQL等。ORM工具允許開發人員使用面向物件的方式處理數據庫操作，並將物件映射到數據庫中的表格。
- ORM 效能損失：
    - 然而，ORM 可能在處理複雜查詢或高度優化的情況下效能下降，因為它需要將物件和關聯型數據庫之間進行轉換。
### OBM (Object-Bucket Mapping)：物件-存儲桶映射
- OBM 含義：
    - OBM是一種用於將應用程序中的物件（Object）映射到分佈式文件系統或對象存儲服務的存儲桶（Bucket）的技術。這種映射在一些雲端存儲場景中比較常見，用於將應用程序數據映射到雲端存儲服務（如Amazon S3、Google Cloud Storage等）。
- OBM 效能損失：
    - 當處理大型文件或需要高度併發時，OBM 可能導致效能損失，這取決於雲端存儲服務的性能和設計。
總的來說，映射技術通常會增加一定的效能損失，特別是在處理大量數據或需要高效率的情況下。在選擇使用哪種映射技術時，需要根據應用程序的需求和預期的性能來權衡利弊。在性能要求較高的情況下，可以考慮使用原生的數據庫驅動程序或針對特定情況進行優化。

# 在 NestJS 專案中 Mongoose vs MongoDB 效能差異
在 NestJS 專案中，你可以使用 Mongoose 或者原生 MongoDB 來與 MongoDB 數據庫進行交互。這兩種方法在效能上有一些差異，這取決於你的應用程序的需求和資料庫操作的複雜性。下面我們來分析一下：

### Mongoose 是 MongoDB 的一個 ODM（物件數據映射）
它提供了一個更高級的抽象層來操作數據庫。使用Mongoose，你可以定義模式（Schemas）和模型（Models），並且它允許你在JavaScript中使用類似於OOP的方式來處理數據庫操作。這使得Mongoose在開發速度和易用性方面非常優越。

### MongoDB 是直接使用 MongoDB 提供的官方Node.js驅動程序（例如mongodb-native-driver）來操作數據庫
需要直接使用 MongoDB 提供的低階 API 進行數據操作，這樣的寫法通常比較接近底層，更靠近 MongoDB 的運行方式。原生 MongoDB 驅動的效能較高，因為它消除了 Mongoose 提供的額外抽象層。當你需要對數據庫進行高度自定義的操作時，這將給你更多控制權，使用原生驅動會更有優勢。

## Mongoose vs MongoDB 效能差異
Mongoose 和原生 MongoDB 驅動程式的效能差異可能會在不同的使用情境中有所變化。然而，通常而言，以下幾個因素可能會影響到你在使用 NestJS 專案時兩者之間的效能：
1. **數據模型化（Data Modeling）**：Mongoose 提供了強大的數據模型化工具，允許你定義數據的結構、驗證、預設值等等。這些工具可以使你的代碼更乾淨、更易於維護，但這可能會導致一些額外的效能開銷。

2. **數據驗證（Data Validation）**：Mongoose 提供了內建的數據驗證機制，這意味著在數據到達 MongoDB 之前就會進行驗證。這可以避免在數據庫層級保存無效的數據，但這種驗證過程可能會增加一些額外的處理時間。

3. **中間件（Middleware）**：Mongoose 支持在執行操作前後使用中間件，這允許你很方便地實現例如日誌記錄、數據修改等功能。然而，如同所有中間件一樣，如果沒有妥善地使用，它們可能會成為效能瓶頸。

4. **更多抽象化（Higher Level of Abstraction）**：Mongoose 提供了一個更高層次的抽象化，使得開發者能更方便地進行數據操作。然而，這樣的便利性可能會以某些程度的效能為代價。

MongoDB 原生驅動提供了對 MongoDB 數據庫的直接操作。它比較底層，因此在處理特殊的查詢或需要完全控制的情況下可能會更加有用。在極度關注效能的情況下，使用原生驅動可能會稍微快一些，因為它少了 Mongoose 提供的數據模型和驗證等額外功能的開銷。Mongoose 是一個在 MongoDB 原生驅動之上的數據建模工具，提供了許多功能，如模型驗證、中間件、查詢構建等。這些功能使得使用 MongoDB 變得更加方便且安全。但是，這些額外的功能可能會對效能造成一些影響，特別是在處理大量請求或大型數據集的情況下。

## 結論
整體來說，原生 MongoDB 驅動程式在效能上可能會稍微優於 Mongoose，因為它提供了更直接、更少抽象的數據庫操作。然而，Mongoose 提供的數據模型化、驗證和中間件功能可以極大地提升開發效率和代碼的可維護性，這些優勢可能會抵銷它在效能上的微小劣勢。最終哪種方法更適合你，將取決於你的具體需求和優先考慮的因素。所以在我看看這兩者之間的主要差別不在於效能，而是在於它們提供的特性和便利性。
- 選擇使用 Mongoose 還是原生 MongoDB 需要考慮你的項目需求和優先事項。如果你更關心快速開發和模型驗證，而對於性能較為寬鬆，那麼 Mongoose 是個不錯的選擇。如果你需要追求極致的性能，並且願意犧牲一些開發便利性，那麼原生 MongoDB 驅動可能更適合你。最好根據項目的實際需求進行選擇。
- 最佳方法是根據你的專案需求和預期的使用情況來選擇適合的方法。你也可以根據不同的場景結合使用兩者，例如在開發階段使用Mongoose，而在性能要求較高的生產環境中使用原生MongoDB。


提高效能的解法。

transaction 的用法，會遇到的狀況
